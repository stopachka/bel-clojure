{"version":3,"sources":["instaparse/transform.cljc"],"mappings":";AAKA,2CAAA,3CAAMA,8FAAqBC,EAAEC;AAA7B,AACE,OAACC,oBAAU,AAACC,4CAAIH,EAAEC,GAAG,AAACG,eAAKH;;AAE7B;;;;kCAAA,lCAAMI,4EAGHC,IAAIC;AAHP,AAIE,GACa,EAAA,GAAA,QAAA,SAAA,EAAA,EAAA,CAAA,0CAAA,eAAA,CAAAC,gCAAA,6BAAA,KAAA,EAAA,EAAA,0CAAA,AAAAC,2DAAA,QAAA,AAAAA,jCAAYC,mEAAAA,pSAAUJ,qBAAAA,0FAAAA,sCAAAA,gGAAAA,mEAAAA;AACjC,OAACK,0BAA0BL,IAAIC;;AAC/BD;;;AAEJ,wCAAA,xCAAOM,wFACJC,cAAcC;AADjB,AAEE,IAAMC,YAAU,iBAAAC,WAAe,AAAA,kFAAMF;AAArB,AAAA,kGAAAE,oCAAAA,9HAACH,8CAAAA,wDAAAA;;AAAjB,AACE,oBACEE;AACA,OAACV,gCACC,AAACY,8CAAMF,UAAU,AAACZ,4CAAI,AAACe,gDAAQN,sCAAiBC,eAC1B,AAAA,uFAAUC,cAChC,AAACV,eAAKU;;AALV,oBAME,AAAA,kFAAMA;AACN,gEAAA,zDAACK,8CAAML,oEAAoB,AAACX,4CAAI,AAACe,gDAAQN,sCAAiBC,eAC1B,AAAA,uFAAUC;;AAR5C,AAUEA;;;;;AAEN,wCAAA,xCAAOM,wFACJP,cAAcC;AADjB,AAEE,GAAI,EAAK,AAACO,4BAAYP,iBAAY,AAACQ,cAAIR;AACrC,IAAAS,qBAAmB,iBAAAC,WAAe,AAACC,gBAAMX;AAAtB,AAAA,kGAAAU,oCAAAA,9HAACX,8CAAAA,wDAAAA;;AAApB,AAAA,oBAAAU;AAAA,gBAAAA,ZAASR;AAAT,AACE,OAACV,gCACC,AAACY,8CAAMF,UAAU,AAACZ,4CAAI,AAACe,gDAAQE,sCAAiBP,eAC1B,AAACa,eAAKZ,cAC5B,AAACV,eAAKU;;AACR,OAACZ,oBACC,6CAAA,7CAACyB,gIAAM,AAACF,gBAAMX,oBACR,AAACX,4CAAI,AAACe,gDAAQE,sCAAiBP,eAC1B,AAACa,eAAKZ,cACjB,AAACV,eAAKU;;;AACVA;;;AAEJ;;;;;;;;iCAAA,jCAAMc,0EAOHf,cAAcC;AAPjB,AASE,GACE,OAASA;AAETA;;AAHF,oBAKE,iBAAAe,oBAAK,AAACC,qBAAKhB;AAAX,AAAA,GAAAe;AAAuB,OAAA,kFAAMf;;AAA7Be;;;AAEA,OAACjB,sCAAiBC,cAAcC;;AAPlC,GASE,EAAK,AAACiB,wBAAQjB,iBAAY,wCAAAkB,vCAAU,AAACP,gBAAMX;AAE3C,OAACM,sCAAiBP,cAAcC;;AAXlC,GAaE,AAACO,4BAAYP;AAGb,OAACf,yCAAoB,AAACmB,gDAAQU,+BAAUf,eAAeC;;AAhBzD,GAkBE,uBAAWmB,tBAAuBnB;AAElCA;;AApBF,AAuBE,+IAAA,xIAACoB","names":["instaparse.transform/map-preserving-meta","f","l","cljs.core/with-meta","cljs.core.map","cljs.core/meta","instaparse.transform/merge-meta","obj","metamap","cljs.core/PROTOCOL_SENTINEL","cljs.core/native-satisfies?","cljs.core/IWithMeta","instaparse.gll/merge-meta","instaparse.transform/enlive-transform","transform-map","parse-tree","transform","G__24412","cljs.core.apply","cljs.core.partial","cljs.core.assoc","instaparse.transform/hiccup-transform","cljs.core/sequential?","cljs.core/seq","temp__5802__auto__","G__24418","cljs.core/first","cljs.core/next","cljs.core.into","instaparse.transform/transform","and__5043__auto__","cljs.core/map?","cljs.core/vector?","cljs.core/Keyword","instaparse.gll/Failure","instaparse.util.throw_illegal_argument_exception"],"sourcesContent":["(ns instaparse.transform\r\n  \"Functions to transform parse trees\"\r\n  (:require [instaparse.gll]\r\n            [instaparse.util :refer [throw-illegal-argument-exception]]))\r\n\r\n(defn map-preserving-meta [f l]\r\n  (with-meta (map f l) (meta l)))\r\n\r\n(defn merge-meta\r\n  \"This variation of the merge-meta in gll does nothing if obj is not\r\nsomething that can have a metamap attached.\"\r\n  [obj metamap]\r\n  (if #?(:clj (instance? clojure.lang.IObj obj)\r\n         :cljs (satisfies? IWithMeta obj))\r\n    (instaparse.gll/merge-meta obj metamap)\r\n    obj))\r\n\r\n(defn- enlive-transform\r\n  [transform-map parse-tree]\r\n  (let [transform (transform-map (:tag parse-tree))]\r\n    (cond\r\n      transform\r\n      (merge-meta \r\n        (apply transform (map (partial enlive-transform transform-map)\r\n                              (:content parse-tree)))\r\n        (meta parse-tree))\r\n      (:tag parse-tree)\r\n      (assoc parse-tree :content (map (partial enlive-transform transform-map)\r\n                                      (:content parse-tree)))\r\n      :else\r\n      parse-tree)))\r\n\r\n(defn- hiccup-transform\r\n  [transform-map parse-tree]\r\n  (if (and (sequential? parse-tree) (seq parse-tree))\r\n    (if-let [transform (transform-map (first parse-tree))]\r\n      (merge-meta\r\n        (apply transform (map (partial hiccup-transform transform-map)\r\n                              (next parse-tree)))\r\n        (meta parse-tree))\r\n      (with-meta \r\n        (into [(first parse-tree)]\r\n              (map (partial hiccup-transform transform-map) \r\n                   (next parse-tree)))\r\n        (meta parse-tree)))\r\n    parse-tree))\r\n\r\n(defn transform\r\n  \"Takes a transform map and a parse tree (or seq of parse-trees).\r\n   A transform map is a mapping from tags to \r\n   functions that take a node's contents and return\r\n   a replacement for the node, i.e.,\r\n   {:node-tag (fn [child1 child2 ...] node-replacement),\r\n    :another-node-tag (fn [child1 child2 ...] node-replacement)}\"\r\n  [transform-map parse-tree]\r\n  ; Detect what kind of tree this is\r\n  (cond\r\n    (string? parse-tree)\r\n    ; This is a leaf of the tree that should pass through unchanged\r\n    parse-tree\r\n\r\n    (and (map? parse-tree) (:tag parse-tree))\r\n    ; This is an enlive tree-seq\r\n    (enlive-transform transform-map parse-tree)\r\n    \r\n    (and (vector? parse-tree) (keyword? (first parse-tree)))\r\n    ; This is a hiccup tree-seq\r\n    (hiccup-transform transform-map parse-tree)\r\n    \r\n    (sequential? parse-tree)\r\n    ; This is either a sequence of parse results, or a tree\r\n    ; with a hidden root tag.\r\n    (map-preserving-meta (partial transform transform-map) parse-tree)\r\n    \r\n    (instance? instaparse.gll.Failure parse-tree)\r\n    ; pass failures through unchanged\r\n    parse-tree\r\n    \r\n    :else\r\n    (throw-illegal-argument-exception\r\n      \"Invalid parse-tree, not recognized as either enlive or hiccup format.\")))\r\n"]}